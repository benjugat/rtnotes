---
title: Proccess Enumeration
category: Maldev-Object Enumeration
order: 1
---

We will need to enumerate, parse and be able to work with the handles and information of the processes to inject or hook them.

There are different ways to enumerate the processes of a system.

# CreateToolhelp32Snapshot (Classic technique) (WinAPI)

The classic technique to find a process is by creating a snapshots with `CreateToolhelp32Snapshot` WINAPI. Once done we can iterate over the names in order to match to the desired one.

* [https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot](https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot)

*Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.*

*If the function succeeds, it returns an open handle to the specified snapshot.*

```cpp
HANDLE CreateToolhelp32Snapshot(
  [in] DWORD dwFlags,
  [in] DWORD th32ProcessID
);
```
*dwFlags=`TH32CS_SNAPPROCESS` -> Includes all processes in the system in the snapshot. To enumerate the processes, see `Process32First`, `Process32Next`*

Final code:

```cpp
#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>

int FindProcess(const char * procname){
    int pid = 0;
    HANDLE hSnapshot;
    PROCESSENTRY32 lppe;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);
    if(INVALID_HANDLE_VALUE == hSnapshot){
        return 0;
    }
    lppe.dwSize = sizeof(PROCESSENTRY32);
    printf("Num of Processes... dwSize -> %d\n", lppe.dwSize);

    // Snapshot done!
    
    if(!Process32First(hSnapshot, &lppe)){
        CloseHandle(hSnapshot);
        return 0;
    }

    while(Process32Next(hSnapshot, &lppe)){
        if(lstrcmpiA(procname, lppe.szExeFile)==0){
            printf("PID -> %d\t%s\n", lppe.th32ProcessID, lppe.szExeFile);
            pid = lppe.th32ProcessID;
            break;
        }
        
    }
    CloseHandle(hSnapshot);    
    return pid;
}

int main(int argc, char ** argv) {
    
    int pid;
    pid = FindProcess("notepad.exe");
    if(pid == 0){
        printf("Process Not found\n");
        return 0;
    }
    printf("pid -> %d\n", pid);
    return 0;
}
```

# EnumProcesses (WinAPI)

`EnumProcess` retrieves a list with all the process identifier of the system.

* [https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses](https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses)


```cpp
BOOL EnumProcesses(
  [out] DWORD   *lpidProcess,
  [in]  DWORD   cb,
  [out] LPDWORD lpcbNeeded
);
```

*To obtain process handles for the processes whose identifiers you have just obtained, call the OpenProcess function*
Once obtained the list we should open the process in order to search the process name.

* [https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)

```cpp
HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,
  [in] BOOL  bInheritHandle,
  [in] DWORD dwProcessId
);
```

There are different ways to obtain the Process Name from the Handle. With `GetModuleBaseNameA` or `QueryFullProcessImageName`. I used `GetModuleBaseNameA` that returns only the executable name.
 
```cpp
#include <Windows.h>
#include <stdio.h>
#include <psapi.h>

#pragma comment(lib, "psapi.lib")

int FindProcess(const char * procname){
    int pid = 0;
    DWORD lpidProcess[1024];
    DWORD cb = sizeof(lpidProcess);
    DWORD lpcbNeeded;
    DWORD numProcesses;
    HANDLE hProc;
    TCHAR procName[1024];

    if(!EnumProcesses(lpidProcess, cb, &lpcbNeeded)){
        return 0;
    }

    // Get the processes list
    numProcesses = lpcbNeeded/sizeof(DWORD);
    for(int i=0; i<numProcesses; i++){
        // Open a Process Handle with a pid
        hProc = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ, FALSE, lpidProcess[i]);
        if(hProc != NULL){
            // Getting the executable name of the process handle
            if(GetModuleBaseNameA(hProc, NULL, procName, 1024) > 0){
                if (lstrcmpiA(procname, procName) == 0) {
                    pid = lpidProcess[i];
                    CloseHandle(hProc);
                    break;
                }
            }
        }
        CloseHandle(hProc);        
    }
    return pid;
}

int main(int argc, char ** argv) {
    
    int pid;
    pid = FindProcess("notepad.exe");
    if(pid == 0){
        printf("Process Not found\n");
        return 0;
    }
    printf("pid -> %d\n", pid);
    return 0;
}
```

# WTSEnumerateProcessA (WinAPI)


# NtQuerySystemInformation (NativeAPI)

# NtGetNextProcess (NativeAPI)